package com.ggp.utils.recall;

import com.ggp.IAction;
import com.ggp.ICompleteInformationState;
import com.ggp.IInformationSet;
import com.ggp.IStrategy;
import com.ggp.games.LeducPoker.GameDescription;
import com.ggp.games.LeducPoker.InformationSet;
import com.ggp.games.LeducPoker.Rounds;
import com.ggp.games.LeducPoker.actions.CallAction;
import com.ggp.games.LeducPoker.actions.FoldAction;
import com.ggp.games.LeducPoker.actions.RaiseAction;
import com.ggp.games.RockPaperScissors.ChooseAction;
import com.ggp.players.deepstack.utils.Strategy;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;

import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

class ImperfectRecallExploitabilityTest {
    @Test
    void testLeduc_alwaysFold() {
        ICompleteInformationState initialState = new GameDescription(7,7).getInitialState();
        IStrategy alwaysFold = new IStrategy() {
            @Override
            public double getProbability(IInformationSet s, IAction a) {
                if (a.getClass() == FoldAction.class) return 1;
                return 0;
            }

            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }
        };

        // always fold strategy will lose 1 chip per game (initial bet)
        assertEquals(1, ImperfectRecallExploitability.computeExploitability(alwaysFold, initialState));
    }

    @Test
    void testLeduc_raiseThenFold() {
        ICompleteInformationState initialState = new GameDescription(7,7).getInitialState();
        IStrategy alwaysFold = new IStrategy() {
            @Override
            public double getProbability(IInformationSet s, IAction a) {
                InformationSet is = (InformationSet) s;
                if (is.getRound() == Rounds.Bet2) {
                    if (a.getClass() == FoldAction.class) return 1;
                } else {
                    if (is.wasRaised() && a.getClass() == CallAction.class) return 1;
                    if (!is.wasRaised() && a.getClass() == RaiseAction.class) return 1;
                }
                return 0;
            }

            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }
        };

        // always fold strategy will lose 3 chips
        assertEquals(3, ImperfectRecallExploitability.computeExploitability(alwaysFold, initialState));
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_uniform(int size) {
        // there is a numerical issue for some RPS sizes
        assertTrue(ImperfectRecallExploitability.computeExploitability(new Strategy(), new com.ggp.games.RockPaperScissors.GameDescription(size)) < 1e-16);
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_singleAction(int size) {
        IStrategy singleAction = new IStrategy() {
            @Override
            public double getProbability(IInformationSet s, IAction a) {
                ChooseAction act = (ChooseAction) a;
                if (act.getChosen() == 1) return 1;
                return 0;
            }

            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }
        };
        assertEquals(1d, ImperfectRecallExploitability.computeExploitability(singleAction, new com.ggp.games.RockPaperScissors.GameDescription(size)));
    }

    static IntStream rpsSizes() {
        return IntStream.of(3, 5, 7, 9, 11, 29);
    }

}