package com.ggp.utils.recall;

import com.ggp.*;
import com.ggp.games.RockPaperScissors.ChooseAction;
import com.ggp.games.RockPaperScissors.GameDescription;
import com.ggp.players.deepstack.utils.Strategy;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;


import java.util.List;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

class PerfectRecallExploitabilityTest {

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_uniform(int size) {
        // there is a numerical issue for some RPS sizes
        assertTrue(PerfectRecallExploitability.computeExploitability(new Strategy(), new GameDescription(size)) < 1e-16);
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_singleAction(int size) {
        IStrategy singleAction = new IStrategy() {
            @Override
            public double getProbability(IInformationSet s, IAction a) {
                ChooseAction act = (ChooseAction) a;
                if (act.getChosen() == 1) return 1;
                return 0;
            }

            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }
        };
        ICompleteInformationState initialState = new GameDescription(size).getInitialState();
        assertEquals(1d, PerfectRecallExploitability.computeExploitability(singleAction, initialState));
        Strategy bestResponse = new Strategy();
        assertEquals(1d, PerfectRecallExploitability.computeExploitability(singleAction, initialState, bestResponse));

        // first action that beats 1 is chosen since all that beat it have the same value.
        assertEquals(1d, bestResponse.getProbability(initialState.getInfoSetForActingPlayer(), new ChooseAction(2 + (size - 1)/2)));
    }

    static IntStream rpsSizes() {
        return IntStream.of(3, 5, 7, 9, 11, 29);
    }

    @Test
    void testTerminal() {
        assertEquals(0d, PerfectRecallExploitability.computeExploitability(new Strategy(), new ICompleteInformationState() {
            @Override
            public boolean isTerminal() {
                return true;
            }

            @Override
            public int getActingPlayerId() {
                return 0;
            }

            @Override
            public double getPayoff(int player) {
                if (player == 1) return 1;
                return -1;
            }

            @Override
            public List<IAction> getLegalActions() {
                return null;
            }

            @Override
            public IInformationSet getInfoSetForPlayer(int player) {
                return null;
            }

            @Override
            public ICompleteInformationState next(IAction a) {
                return null;
            }

            @Override
            public Iterable<IPercept> getPercepts(IAction a) {
                return null;
            }

            @Override
            public IRandomNode getRandomNode() {
                return null;
            }
        }));
    }
}